---
layout: article-detail
category: 工作记录 
author: 龙飞 
title: 数据及服务迁移记录
---

来到头条半年多，从游戏行业跨入互联网行业，看起来差别不大，个中滋味非经历不能体会。除了都用Python写一些东西之外，其他种种都要自学。Live and learn.

这半年参与的最重要的事情就是数据库和数据服务的迁移。当初接到这个任务的时候，天真地以为至多两个月就能搞定，最终却几乎耗费了三倍的时间。这过程中包含了学习的开销，需求的变更带来的花费，与上游沟通的成本，当然更少不了走弯路带来的不必要的额外花销。趁着还没有忘记主要流程，把这部分内容写下来，是有此文。

## 我们要做什么 
图da data_access + video库 + Python客户端DAL + smart_player + others 

video库存放所有视频相关数据，比如原视频存放地址，转码后视频地址，视频数据元信息等。data_access为原来读写数据的服务。Python dal为切换到微服务之前，原来Python客户端读写数据服务的代码。smart_player是点播读取视频地址的服务，只有读请求。others表示其他一些请求，这些请求有的直接访问DB，有的通过data_access服务访问DB。

上述结构的问题是：
- 数据访问不收敛，一个需求变更可能需要多处改动。因为有些访问缺乏统计和监控，出问题时也不方便迅速定位。
- 原数据库表结构设计不十分合理，比如转码后视频和原视频分开存储，前者以后者在数据表中的自增ID作为索引。但实际使用中都是使用video_id(32位的uuid)，如果要用一个video_id查出视频相关数据，则需要两次查询（orm不推荐使用join)。
- 还有个相关的原因是，之前转码使用的celery做任务调度，但是当视频量逐渐上升之后，渐渐不能满足需求了。

为此，我们决定把数据库重新设计。同时将所有访问都收敛到一个新的数据层服务。重构之后长这个样子。

图vda

这个图就清爽多了。

## 怎么做
1. DB重构
简单示意一下，原有表结构是这样的。

现在表结构是这样的。主要包含三张表：video_upload, video_info, video_extra。video_upload主要存储视频在上传转码流程中的信息，比如是否上传成功，是否转码成功，由谁上传等。video_info存储跟视频文件（包括原始视频和转码后视频）相关的信息，比如视频元信息，存储地址，转码格式等。后来又陆续加入了水印类型，codec类型等数据，此是后话，暂且不表。video_extra则主要存储一些部分视频有的数据，比如水印检测信息等等。

2. 数据服务重构上线

原来服务叫做data_access，重构后的服务叫video_data_access。

图da & vda

data_accss服务使用了两层Redis做cache，一层为缓存型，过期时间较短，一层为持久型，过期时间较长。设计的目的是尽量减少打到DB的流量。这种设计要求第二层缓存容量显著大于第一层容量才能有效利用空间，然而我们的线上环境并没有配置成这样，所以第二层Redis的命中率长期保持在20%以下。

video_data_access基本上继承了data_access的结构，区别有三处。
- 去掉第二层Redis，改用Abase。后者是在线KV数据库，容量足够大，足以容纳一年以上的视频数据。
- 增加一个MD5Redis，用来存储上传文件的MD5，用作消重。
- 每当DB有写操作时，都会写入NSQ。上层smart_player会消费NSQ，写入自己的缓存，用于容灾。
video_data_access还需要考虑另外一个问题，如何不着痕迹地替换线上一直运行的data_access？有两个方案可选。
1. 快速上线，直接切换服务，在某个指定时间段内完成。但考虑到我们15k+的qps，以及分散的上游调用，这种方法很难实现。
2. 用较长的一段时间来进行切换，双写双读两个数据库，校验数据准确率达到4个9以上之后进行切换。

我们很自然地采用了第二种方案，为了不影响视频的正常播放，我们决定先切写，稳定后再切读流量。好怀念做游戏的时候可以停服维护的日子！

----------------------------------------------------------------
长期的线下测试对比过程，保证数据100%match（实际不是100%，因为新库会删掉一些不需要的字段，另加一些字段，这些在对比时忽略）
----------------------------------------------------------------

是时候把我们的服务部署上线了，注意这一步还没有接入流量。

这种方案也有需要思考的地方：双读不用说，肯定是先读新库，如果没有再读老库。双写是先写新库还是先写老库呢？我们决定先写新库，因为最终的目的是使用新库，如果写入有错能尽早地暴露问题。The sooner, the better.
为了保证写入新库数据的正确性，我们需要足够长的时间来进行数据校验。
为了保证线上数据正确性，必须两个库都写成功才回给客户端返回成功。毫无疑问，这增加了我们服务出错的概率，因此我们需要尽量缩短双写状态持续的时间。可见上述两个要求是相互矛盾的。暂且忽略这个问题。


3. 收敛部分线上流量到video_data_access
warning: 前面两步都是离线操作，随时可以删除重来。但是从这一步开始，以后的操作都跟线上环境相关，必须小心谨慎。
这里的部分流量指的是指那些还没有收敛到data_access服务的写流量。这只占所有流量很小的一部分，即使有影响也比较可控。
同样也是因为流量较小，我们的对比工作进行得不太顺利。所以我们需要更多的流量。

4. 切换转码流量到video_data_access
前面提到了，除了用户上传的原始视频之外，转码后的视频数据也是DB写入量的一大来源(事实上因为一个原始视频会转出多个分辨率，转码后视频数据量是原视频的若干倍）。
转码的全部输入来自于用户上传的数据，只要上传数据不丢，即使转码失败也可以修复。如果上传写入失败，那么这个视频就无法正确放出了。所以我们选择先迁移转码的写流量。
如何区分上传和转码的流量呢，我们将video_data_access部署了default和write两个集群，前者用于上传，后者用于转码，在代码中控制。

5. 切换上传流量到video_data_access
在测试对比将近两周之后，我们认为是时候完全收敛写流量了。请注意，这里要面对一个很严峻的问题：如果切换上传失败，那么用户在这一段时间的数据将会永远消失，没有任何恢复的办法。
为此，我们作了周密的计划：
-- 在23:00以后切换，因为这段时间上传量达到每天的最小值
事实证明，这是一个英明的决策，我们大概花了一个通宵的时间来完成这个过程。期间各种trail and error，大致原因是上传也有若干版本，没有完全收敛。具体细节记不太清楚了，这也说明了事后马上记录的意义。

6. 数据迁移，读接口校验 
这里我们又到了一个比较轻松的阶段，只需要定期从新库和老库中取出数据对比即可。除此之外，还有一个看起来简单却异常麻烦的工作：导数据。因为服务现在采用双写，所以只需要导入切流量之前的数据即可。
我们的数据库存储了2015年头条的第一条视频到现在的所有数据，并且每天以百万级别的量（写文章的时候已经近500万）在增加。总共约3亿条（这里单指原始视频，如果加上转码后视频，会再增加一个数量级）。
同时虽然data_access服务加了两次cache，但是还是有上千的QPS打到后端DB。如何能快速导完数据并且不影响线上流量？多进程+读从库可破之。之所以使用多进程是因为人生苦短，我用Python。
有一段时间开发机上将近40个100%CPU的Python进程就是我的作品。

然而导完了只不过完成了一小部分工作，主要工作是不停地对比。比到山无棱，天地合。对比并不是无意义的，每次都能扫出一些不一样的东西。
这一步的主要问题有：
- 导数据中断如何恢复？因为每个进程的数据是预先划分好的，所以每个进程用一个文件记录导入进度即可。
- 脏数据清洗。因为老DB没有加Uniq索引，所以会出现重复数据，同时还会有一些残缺数据，以及无用数据（比如未上传的）。
- 如何找到合适的进程数和单次读取DB条数? Trial and error，时刻关注监控。 

7. 切换到Sharding数据库,导数据again
在数据还没对比完的时候，我们发现一个问题：按照目前这种增长速度，单个DB很快就不够用了。于是引入了分库，这个库被命名为sharding库。
所以我们的写流量需要切换到sharding库，然后下掉core库。这个过程参见***********************
自然，切完流量后，导数据流向就变成了从video库到Sharding库。
sharding库是用Mycat作为代理的。关于Mycat，要吐槽的地方实在太多了，参见*****************************

8. 上游读对比
好了，到这里终于可以切读流量了。虽然我们之前对比过DB的数据，但是因为cache的关系，我们还需要调用服务，比较data_access和video_data_access服务的输出是否一致。
这一步由上游的smart_player完成，服务本身并不需要做什么改动。

对比过程也出现了很多不一致的情况，除了DB里确实有不一样的情况之外，主要是Redis里面的脏数据导致，处理也很简单，调用服务清理Redis的接口即可。

9. 上游所有读流量收敛到smart_player 
上游对比完成之后，我们就着手切换读流量了。
首先确保所有读流量都收敛到smart_player服务--这主要是一些沟通方面的工作。
事实上这一步放在切完流量之后也行，但是考虑到我们老服务不久之后就会下线，所以还是尽快让上游迁移比较好。

10. 上游切换读流量
终于看到胜利的曙光，这最后一步，看起来也是最胆战心惊的一步。
然而是用了三天左右的时间缓慢切完的。中间也基本没出任何纰漏。
原因是上游的smart_player也作了重构，重构的版本正好读的是video_data_access服务。虽然我们的idl格式变了，但是上游smart_player把变化都包含在内了，对外暴露的接口没变。
所以此处只需要切换smart_player两个版本之间的流量比就可以了。至于为什么可以直接切量，因为主要工作都在第8步对比过程完成了。
那么为什么用了三天呢？因为需要充cache。如果直接全切，DB瞬间就被打挂掉了。

11. 代码重构
切换完成之后，做了一次代码重构，虽然接口没变，但是因为存cache的数据结构都变了，上线也费了很多精力。有感兴趣者咨询@邝昌浪。

## 写在最后
没想到迁移一个DB竟然花了这么长时间。分享一下自己学到的东西。
1. 花费了太多精力来处理上线过程中各机器代码不一致的问题，如果我们能把微服务做到松耦合高内聚，流程尽量缩短，甚至只有一步（或者说各步骤之间没有依赖），那么无论多少台机器代码不一样，都不会有问题。
2. 服务收敛，不管是维护，还是切流量，都会简单很多。
3. 提前做好方案review，尽量简化流程，the simpler the better. 可以避免大多数问题。
4. 时候为自己的代码负责，尽量保持接口不变。这次迁移若不是smart_player兜底，又要花费许多时间来改写接入层。
5. 学习优秀代码设计，始终在路上。
